#include <QApplication>
#include <QGridLayout>
#include <QPushButton>
#include <QWidget>
#include <cstdlib>
#include <ctime>
#include <QLabel>
#include <vector>
#include <iostream>

int score=0;

class Barco {
public:
    Barco() : com_barco(false) {}

    bool com_barco;
    Barco(int linha, int coluna) : linha(linha), coluna(coluna) {}

        int getLinha() const { return linha; }
        int getColuna() const { return coluna; }

    private:
        int linha;
        int coluna;

};

class TabuleiroJogador : public QWidget {
public:
    TabuleiroJogador(QWidget* parent = nullptr) : QWidget(parent), contadorCliques(0) {
        QGridLayout* gridLayout = new QGridLayout(this);
        gridLayout->setSpacing(0);
        gridLayout->setContentsMargins(0, 0, 0, 0);

        for (int i = 0; i < 10; ++i) {
            for (int j = 0; j < 10; ++j) {
                QPushButton* button = new QPushButton(this);
                button->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
                gridLayout->addWidget(button, i, j);

                // Conecta o sinal clicked do botão à função onButtonClicked
                connect(button, &QPushButton::clicked, this, [this, button]() {
                    onButtonClicked(button);
                });

                // Inicializa o barco como nullptr para todas as posições
                botoes[i][j] = nullptr;
            }
        }
    }

    Barco* getBarcoAtPosicao(int linha, int coluna) {
        if (botoes[linha][coluna])
            return &botoes[linha][coluna]->barco;
        else
            return nullptr;
    }

    struct Botao {
        QPushButton* button;
        Barco barco;
    };

    Botao* botoes[10][10]; // Matriz de botões do tabuleiro do jogador
    int contadorCliques; // Contador de cliques realizados

private:
    void onButtonClicked(QPushButton* button) {
        if (contadorCliques < 3){  // Limite de 3 cliques

            button->setEnabled(false);
            button->setStyleSheet("background-color: gray");

            // Encontra a posição do botão clicado
            int linha = -1;
            int coluna = -1;
            for (int i = 0; i < 10; ++i) {
                for (int j = 0; j < 10; ++j) {
                    if (botoes[i][j] && botoes[i][j]->button == button) {
                        linha = i;
                        coluna = j;
                        break;
                    }
                }
                if (linha != -1 && coluna != -1)
                    break;
            }

            // Atualiza a posição do barco no TabuleiroJogador
            if (linha != -1 && coluna != -1) {
                if (!botoes[linha][coluna]) {
                    Botao* novoBotao = new Botao;
                    novoBotao->button = button;
                    botoes[linha][coluna] = novoBotao;
                }
                botoes[linha][coluna]->barco.com_barco = true;

            }
            contadorCliques++;
        }


        else {
              new QLabel("Todos barcos estão no tabuleiro");
              return;
        }
      }
  };
class TabuleiroAdversario : public QWidget {
public:
    TabuleiroAdversario(QWidget* parent = nullptr) : QWidget(parent) {
        gridLayout = new QGridLayout(this);
        gridLayout->setSpacing(0);
        gridLayout->setContentsMargins(0, 0, 0, 0);

        for (int i = 0; i < 10; ++i) {
            for (int j = 0; j < 10; ++j) {
                QPushButton* button = new QPushButton(this);
                button->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
                connect(button, &QPushButton::clicked, this, [this, button]() {
                    onButtonClicked(button);
                });
                gridLayout->addWidget(button, i, j);
                buttons[i][j] = button;
            }
        }

        colocarBarcosAleatorios();
    }

private:
    QGridLayout* gridLayout;
    QPushButton* buttons[10][10];
    std::vector<Barco> barcos;

    void colocarBarcosAleatorios() {
        srand(time(0));

        while (barcos.size() < 3) {
            int linha = rand() % 10;
            int coluna = rand() % 10;
            Barco barco(linha, coluna);
            bool posicaoRepetida = false;

            for (const auto& b : barcos) {
                if (b.getLinha() == linha && b.getColuna() == coluna) {
                    posicaoRepetida = true;
                    break;
                }
            }

            if (!posicaoRepetida) {
                barcos.push_back(barco);
                buttons[linha][coluna]->setProperty("com_barco", true);
            }
        }
    }

    void onButtonClicked(QPushButton* button) {
        button->setEnabled(false);

        int linha = -1, coluna = -1;
        for (int i = 0; i < 10; ++i) {
            for (int j = 0; j < 10; ++j) {
                if (buttons[i][j] == button) {
                    linha = i;
                    coluna = j;
                    break;
                }
            }
            if (linha != -1 && coluna != -1)
                break;
        }

        if (button->property("com_barco").isValid()) {
            button->setStyleSheet("background-color: red");
            score ++;
            if (score == 3) {

                QApplication::closeAllWindows();

                QWidget* vitoriaWindow = new QWidget;
                QVBoxLayout* layout = new QVBoxLayout(vitoriaWindow);
                QLabel* label = new QLabel("Parabéns, você venceu!", vitoriaWindow);
                // Definindo o tamanho da fonte
               QFont font = label->font();
               font.setPointSize(30);
               label->setFont(font);
               label->setAlignment(Qt::AlignCenter);
               layout->addWidget(label);
               vitoriaWindow->setLayout(layout);
               vitoriaWindow->showMaximized(); // Maximiza a janela na tela
               vitoriaWindow->setAttribute(Qt::WA_DeleteOnClose); // Define a propriedade para deletar a janela ao fechá-la
                }
        }
            else {
                button->setStyleSheet("background-color: blue");
        }
    }
};

int main(int argc, char* argv[]) {
    std::srand(std::time(nullptr)); // Inicializa a semente para geração de números aleatórios

    QApplication app(argc, argv);

    TabuleiroJogador tabuleiroJogador; // Cria o tabuleiro do jogador
    TabuleiroAdversario tabuleiroAdversario(&tabuleiroJogador); // Cria o tabuleiro do adversário passando o tabuleiro do jogador como referência

    QWidget window;
    QVBoxLayout* layout = new QVBoxLayout(&window);

    // Adiciona o TabuleiroJogador com um título
    QVBoxLayout* tabuleiroJogadorLayout = new QVBoxLayout;
    QLabel* tabuleiroJogadorLabel = new QLabel("Tabuleiro do Jogador");
    tabuleiroJogadorLabel->setAlignment(Qt::AlignCenter);
    tabuleiroJogadorLayout->addWidget(tabuleiroJogadorLabel);
    tabuleiroJogadorLayout->addWidget(&tabuleiroJogador);
    layout->addLayout(tabuleiroJogadorLayout);

    // Adiciona o TabuleiroAdversario com um título
    QVBoxLayout* tabuleiroAdversarioLayout = new QVBoxLayout;
    QLabel* tabuleiroAdversarioLabel = new QLabel("Tabuleiro do Adversário");
    tabuleiroAdversarioLabel->setAlignment(Qt::AlignCenter);
    tabuleiroAdversarioLayout->addWidget(tabuleiroAdversarioLabel);
    tabuleiroAdversarioLayout->addWidget(&tabuleiroAdversario);
    layout->addLayout(tabuleiroAdversarioLayout);
    
    window.show();

    return app.exec(); 
}
